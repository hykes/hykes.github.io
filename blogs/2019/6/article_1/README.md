# 聊聊什么是缓存穿透、缓存击穿、缓存雪崩

在分布式系统或者高并发场景下，我们常常会引入 Redis 作为缓存中间件。一个基本的缓存使用流程如下：

![缓存流程](1.jpg ':size=500x350')

当需要查询一条数据时，先通过 Key 查询缓存，如果缓存有值则直接返回，如果为空则查询数据库，然后返回(有值时写入缓存)。下面来分析一个这个流程图存在的一些问题。

## 缓存穿透

### 1.概念

正常情况下，我们会根据一个确定的 Key 进行查询，即数据是存在的，通常只需要查询一次DB，写入缓存即可。但是，如果用一个不存在 Key 去查询数据，那么每次请求都会落到数据库中。这种查询不存在数据的现象我们称为缓存穿透。

### 2.产生的问题

试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的key发起大量的请求，这可能会导致数据库由于压力过大而宕机。

### 3.解决方案

1. 缓存空值

之所以会发生缓存穿透是因为缓存中没有存储这些为空的值，从而导致请求都落到了数据库中。那么我们可以将这些空值也缓存起来，这样下次再查询这个空值Key时直接返回空即可，同时需要注意设置过期时间。

2. 布隆过滤器

本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构（probabilistic data structure），特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。

修改基本流程，在查询之前在先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存->数据库。

流程图如下：

![缓存流程](2.jpg ':size=500x350')

## 缓存击穿

### 1.概念

在高并发场景或者存在热点 Key 的情况下，大量的请求同时查询一个 Key，如果此时 Key 正好失效（如Redis过期），就会导致大量的请求都落到数据库。这种现象我们称为缓存击穿。

### 2.产生的问题

可以想到，如果某一个时刻发生了缓存击穿，数据库压力加剧，从而导致宕机。

### 3.解决方案

多个请求查询同一个 Key，那么就可以在查询数据库前加一个互斥锁来锁住这段逻辑，串行执行减小数据库压力。但是，由于它会阻塞其他的线程，使得系统吞吐量下降，所以需要我们结合实际业务衡量利弊。

## 缓存雪崩

### 1.概念

某一时刻，缓存中大量 Key 失效，这时大量的请求就会落到数据库中。这种现象我们称为缓存雪崩。与缓存击穿单个热点 Key 失效不同，缓存雪崩是大量不同的 Key 失效。

### 2.产生的问题

与缓存击穿类似，数据库压力加剧，从而导致宕机。

### 3.解决方案

为了避免这些缓存 Key 大规模失效，应该尽量将过期时间均匀分布。比如在一个基础的时间上加上一个随机值。